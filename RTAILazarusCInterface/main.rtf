{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red160\green160\blue160;\red0\green0\blue0;\red128\green128\blue255;\red0\green128\blue128;\red128\green0\blue0;\red240\green0\blue240;\red0\green0\blue160;\red0\green160\blue0;\red0\green0\blue255;\red224\green160\blue0;\red255\green0\blue0;\red128\green255\blue255;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs16   1  \cb3\cf2 //Instead of writing an interface function to the RTAI functions in pascal,
\par \cb1\cf0\ul0\i0\b0   2  \cb3\cf2 //it is easier to write a simple library that uses the functions I need.
\par \cb1\cf0\ul0\i0\b0   3  \cb3\cf2 //This avoids the problem of working out the C definitions for the RTAI
\par \cb1\cf0\ul0\i0\b0   4  \cb3\cf2 //header files
\par \cb1\cf0\ul0\i0\b0   5  \cb3\cf2 //Started March 16, 2011
\par \cb1\cf0\ul0\i0\b0   6  \cb3\cf2 //Last updated March 29, 2011
\par \cb1\cf0\ul0\i0\b0   7  
\par \cb1\cf0\ul0\i0\b0   8  \cb3\cf2 //The standard  libraries
\par \cb1\cf0\ul0\i0\b0   9  \cb3\cf9 #include <stdio.h>
\par \cb1\cf0\ul0\i0\b0  10  \cb3\cf9 #include <stdlib.h>
\par \cb1\cf0\ul0\i0\b0  11  \cb3\cf9 #include <unistd.h>
\par \cb1\cf0\ul0\i0\b0  12  \cb3\cf9 #include <fcntl.h>
\par \cb1\cf0\ul0\i0\b0  13  \cb3\cf9 #include <sys/mman.h>
\par \cb1\cf0\ul0\i0\b0  14  \cb3\cf9 #include <sys/io.h>
\par \cb1\cf0\ul0\i0\b0  15  \cb3\cf9 #include <math.h>
\par \cb1\cf0\ul0\i0\b0  16  
\par \cb1\cf0\ul0\i0\b0  17  
\par \cb1\cf0\ul0\i0\b0  18  
\par \cb1\cf0\ul0\i0\b0  19  \cb3\cf2 //The RTAI libraries
\par \cb1\cf0\ul0\i0\b0  20  \cb3\cf9 #include <rtai_lxrt.h>
\par \cb1\cf0\ul0\i0\b0  21  \cb3\cf9 #include <rtai_msg.h>
\par \cb1\cf0\ul0\i0\b0  22  \cb3\cf9 #include <rtai_comedi.h>
\par \cb1\cf0\ul0\i0\b0  23  \cb3\cf9 #include <rtai_spm.h>
\par \cb1\cf0\ul0\i0\b0  24  
\par \cb1\cf0\ul0\i0\b0  25  
\par \cb1\cf0\ul0\i0\b0  26  \cb3\cf2 //define some constants
\par \cb1\cf0\ul0\i0\b0  27  \cb3\cf9 #define CPUMAP 0xF
\par \cb1\cf0\ul0\i0\b0  28  \cb3\cf9 #define NCHAN 1
\par \cb1\cf0\ul0\i0\b0  29  \cb3\cf9 #define PID_cutoff_N 20
\par \cb1\cf0\ul0\i0\b0  30  \cb3\cf9 #define MaxvOutput 1000
\par \cb1\cf0\ul0\i0\b0  31  \cb3\cf9 #define MinvOutput -1000
\par \cb1\cf0\ul0\i0\b0  32  
\par \cb1\cf0\ul0\i0\b0  33  
\par \cb1\cf0\ul0\i0\b0  34  \cb3\cf2 //the queue.ch file
\par \cb1\cf0\ul0\i0\b0  35  \cb3\cf9 #include <queue.c>
\par \cb1\cf0\ul0\i0\b0  36  
\par \cb1\cf0\ul0\i0\b0  37  \cb3\cf2 //some types
\par \cb1\cf0\ul0\i0\b0  38  
\par \cb1\cf0\ul0\i0\b0  39  
\par \cb1\cf0\ul0\i0\b0  40  \cb3\cf2 // The functions contained in this file are pretty dummy
\par \cb1\cf0\ul0\i0\b0  41  \cb3\cf2 // and are included only as a placeholder. Nevertheless,
\par \cb1\cf0\ul0\i0\b0  42  \cb3\cf2 // they *will* get included in the shared library if you
\par \cb1\cf0\ul0\i0\b0  43  \cb3\cf2 // don't remove them :)
\par \cb1\cf0\ul0\i0\b0  44  \cb3\cf2 //
\par \cb1\cf0\ul0\i0\b0  45  \cb3\cf2 // Obviously, you 'll have to write yourself the super-duper
\par \cb1\cf0\ul0\i0\b0  46  \cb3\cf2 // functions to include in the resulting library...
\par \cb1\cf0\ul0\i0\b0  47  \cb3\cf2 // Also, it's not necessary to write every function in this file.
\par \cb1\cf0\ul0\i0\b0  48  \cb3\cf2 // Feel free to add more files in this project. They will be
\par \cb1\cf0\ul0\i0\b0  49  \cb3\cf2 // included in the resulting library.
\par \cb1\cf0\ul0\i0\b0  50  
\par \cb1\cf0\ul0\i0\b0  51  
\par \cb1\cf0\ul0\i0\b0  52  
\par \cb1\cf0\ul0\i0\b0  53  \cb3\cf2 //static pthread_t pid_thread; // Points to where the thread ID will be stored
\par \cb1\cf0\ul0\i0\b0  54  \cb3\cf8\b static \b0\cb1\cf0 RT_TASK \cb3\cf12 *\cb1\cf0 PIDloop_Task\cb3\cf12 ; \cb3\cf2 // Pid  task
\par \cb1\cf0\ul0\i0\b0  55  
\par \cb1\cf0\ul0\i0\b0  56  \cb3\cf2 //static pthread_t sine_thread; // Points to where the thread ID will be stored
\par \cb1\cf0\ul0\i0\b0  57  \cb3\cf8\b static \b0\cb1\cf0 RT_TASK \cb3\cf12 *\cb1\cf0 Sinewaveloop_Task\cb3\cf12 ; \cb3\cf2 // Pid  task
\par \cb1\cf0\ul0\i0\b0  58  \cb3\cf8\b static \b0\cb1\cf0 RTIME expected\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  59  \cb3\cf8\b static double \b0\cb1\cf0 start_time\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  60  \cb3\cf8\b static double \b0\cb1\cf0 old_time\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  61  \cb3\cf8\b static double \b0\cb1\cf0 current_time\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  62  \cb3\cf8\b static \b0\cb1\cf0 RT_TASK \cb3\cf12 *\cb1\cf0 GlobalTask\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  63  
\par \cb1\cf0\ul0\i0\b0  64  
\par \cb1\cf0\ul0\i0\b0  65  \cb3\cf2 //*****************************************************************************
\par \cb1\cf0\ul0\i0\b0  66  
\par \cb1\cf0\ul0\i0\b0  67  \cb3\cf8\b int \b0\cb1\cf0 StartMainTask\cb3\cf12 ( \cb3\cf8\b int \b0\cb1\cf0 priority\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0  68  \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0  69   \cb3\cf2 //function to start a real time task with the given priority
\par \cb1\cf0\ul0\i0\b0  70   \cb3\cf2 //StartMainTask is designed to be called from the Pascal Program to start the Main (i.e., Pascal) rt program
\par \cb1\cf0\ul0\i0\b0  71  
\par \cb1\cf0\ul0\i0\b0  72  
\par \cb1\cf0\ul0\i0\b0  73       \cb3\cf8\b if\b0\cb3\cf12 (!(\cb1\cf0 GlobalTask \cb3\cf12 = \cb1\cf0 rt_task_init_schmod\cb3\cf12 (\cb1\cf0 nam2num\cb3\cf12 ( \cb3\cf10 "SomeTask" \cb3\cf12 ), \cb3\cf2 // Name
\par \cb1\cf0\ul0\i0\b0  74                                          \cb1\cf0 priority\cb3\cf12 , \cb3\cf2 // Priority
\par \cb1\cf0\ul0\i0\b0  75                                          \cb3\cf7 0\cb3\cf12 , \cb3\cf2 // Stack Size
\par \cb1\cf0\ul0\i0\b0  76                                          \cb3\cf7 0\cb3\cf12 , \cb3\cf2 //, // max_msg_size
\par \cb1\cf0\ul0\i0\b0  77                                          \cb1\cf0 SCHED_FIFO\cb3\cf12 , \cb3\cf2 // Policy
\par \cb1\cf0\ul0\i0\b0  78                                          \cb1\cf0 CPUMAP \cb3\cf12 ))) \cb3\cf2 // cpus_allowed
\par \cb1\cf0\ul0\i0\b0  79          \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0  80              \cb3\cf8\b return \b0\cb3\cf7 1\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  81          \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0  82         \cb3\cf8\b else \b0\cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0  83             \cb3\cf8\b return \b0\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  84         \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0  85  \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0  86  
\par \cb1\cf0\ul0\i0\b0  87  
\par \cb1\cf0\ul0\i0\b0  88  \cb3\cf2 //***************************************************************************************
\par \cb1\cf0\ul0\i0\b0  89  \cb3\cf8\b int \b0\cb1\cf0 EndMainTask\cb3\cf12 ()
\par \cb1\cf0\ul0\i0\b0  90  \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0  91      \cb3\cf2 //EndMainTask is designed to be called from the Pascal Program to end the Main (i.e., Pascal) rt program
\par \cb1\cf0\ul0\i0\b0  92      \cb1\cf0 rt_task_delete\cb3\cf12 (\cb1\cf0 GlobalTask\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0  93     \cb3\cf8\b return \b0\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0  94  \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0  95  
\par \cb1\cf0\ul0\i0\b0  96  \cb3\cf2 //****************************************************************************************
\par \cb1\cf0\ul0\i0\b0  97  
\par \cb1\cf0\ul0\i0\b0  98  \cb3\cf8\b int \b0\cb1\cf0 sineoutput\cb3\cf12 ()
\par \cb1\cf0\ul0\i0\b0  99   \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 100      \cb3\cf2 //Initial test function to try out Real time stuff.
\par \cb1\cf0\ul0\i0\b0 101      \cb3\cf8\b int \b0\cb1\cf0 m\cb3\cf12 , \cb1\cf0 i\cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 102      \cb1\cf0 lsampl_t data_to_card\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 103      \cb3\cf8\b static \b0\cb1\cf0 comedi_t \cb3\cf12 * \cb1\cf0 dev\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 104  
\par \cb1\cf0\ul0\i0\b0 105      \cb1\cf0 dev \cb3\cf12 = \cb1\cf0 comedi_open\cb3\cf12 (\cb1\cf0 device_names\cb3\cf12 [\cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 board_number\cb3\cf12 ]);
\par \cb1\cf0\ul0\i0\b0 106  
\par \cb1\cf0\ul0\i0\b0 107      \cb3\cf8\b if\b0\cb3\cf12 (!(\cb1\cf0 Sinewaveloop_Task \cb3\cf12 = \cb1\cf0 rt_task_init_schmod\cb3\cf12 (\cb1\cf0 nam2num\cb3\cf12 ( \cb3\cf10 "Sinewave" \cb3\cf12 ), \cb3\cf2 // Name
\par \cb1\cf0\ul0\i0\b0 108                                          \cb3\cf7 2\cb3\cf12 , \cb3\cf2 // Priority
\par \cb1\cf0\ul0\i0\b0 109                                          \cb3\cf7 0\cb3\cf12 , \cb3\cf2 // Stack Size
\par \cb1\cf0\ul0\i0\b0 110                                          \cb3\cf7 0\cb3\cf12 , \cb3\cf2 //, // max_msg_size
\par \cb1\cf0\ul0\i0\b0 111                                          \cb1\cf0 SCHED_FIFO\cb3\cf12 , \cb3\cf2 // Policy
\par \cb1\cf0\ul0\i0\b0 112                                          \cb1\cf0 CPUMAP \cb3\cf12 ))) \cb3\cf2 // cpus_allowed
\par \cb1\cf0\ul0\i0\b0 113          \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 114              \cb1\cf0 printf\cb3\cf12 (\cb3\cf10 "ERROR: Cannot initialize sinewave task\n"\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 115              \cb1\cf0 exit\cb3\cf12 (\cb3\cf7 1\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 116          \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 117  
\par \cb1\cf0\ul0\i0\b0 118      \cb3\cf2 //specify that this is to run on one CPU
\par \cb1\cf0\ul0\i0\b0 119      \cb1\cf0 rt_set_runnable_on_cpuid\cb3\cf12 (\cb1\cf0 Sinewaveloop_Task\cb3\cf12 , \cb3\cf7 0\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 120      \cb3\cf2 //Convert samp_time, which is in nanoseconds, to tick time
\par \cb1\cf0\ul0\i0\b0 121      \cb3\cf2 //sampling_interval = nano2count(SAMP_TIME);  //Converts a value from
\par \cb1\cf0\ul0\i0\b0 122                                                  \cb3\cf2 //nanoseconds to internal count units.
\par \cb1\cf0\ul0\i0\b0 123      \cb1\cf0 mlockall\cb3\cf12 (\cb1\cf0 MCL_CURRENT\cb3\cf12 |\cb1\cf0 MCL_FUTURE\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 124      \cb1\cf0 rt_make_hard_real_time\cb3\cf12 ();
\par \cb1\cf0\ul0\i0\b0 125      \cb1\cf0 sampling_interval \cb3\cf12 =\cb1\cf0 nano2count\cb3\cf12 (\cb1\cf0 SAMP_TIME\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 126       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "Sampling interval is %f12 \n"\cb3\cf12 ,\cb1\cf0 count2nano\cb3\cf12 ((\cb3\cf8\b float\b0\cb3\cf12 ) \cb1\cf0 sampling_interval\cb3\cf12 ));
\par \cb1\cf0\ul0\i0\b0 127      \cb3\cf2 // Let's make this task periodic..
\par \cb1\cf0\ul0\i0\b0 128      \cb1\cf0 expected \cb3\cf12 = \cb1\cf0 rt_get_time\cb3\cf12 () + \cb3\cf7 100\cb3\cf12 *\cb1\cf0 sampling_interval\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 129  
\par \cb1\cf0\ul0\i0\b0 130  
\par \cb1\cf0\ul0\i0\b0 131  
\par \cb1\cf0\ul0\i0\b0 132      \cb1\cf0 rt_task_make_periodic\cb3\cf12 (\cb1\cf0 Sinewaveloop_Task\cb3\cf12 , \cb1\cf0 expected\cb3\cf12 , \cb1\cf0 sampling_interval\cb3\cf12 ); \cb3\cf2 //period in counts
\par \cb1\cf0\ul0\i0\b0 133      \cb3\cf2 //rt_task_resume(Sinewaveloop_Task);
\par \cb1\cf0\ul0\i0\b0 134      \cb1\cf0 sine_loop_running\cb3\cf12 =\cb3\cf7 1\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 135  
\par \cb1\cf0\ul0\i0\b0 136  
\par \cb1\cf0\ul0\i0\b0 137  
\par \cb1\cf0\ul0\i0\b0 138      \cb3\cf2 // Concurrent function Loop
\par \cb1\cf0\ul0\i0\b0 139  
\par \cb1\cf0\ul0\i0\b0 140  
\par \cb1\cf0\ul0\i0\b0 141       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "SineWaveAmplitude is is %f \n"\cb3\cf12 ,\cb1\cf0 SineWaveAmplitude\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 142       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "SineWaveFrequency is %f \n"\cb3\cf12 ,\cb1\cf0 SineWaveFrequency\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 143       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "sine_loop_running is %d \n"\cb3\cf12 ,\cb1\cf0 sine_loop_running\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 144       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "SAMP_TIME is %d \n"\cb3\cf12 ,\cb1\cf0 SAMP_TIME\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 145       \cb1\cf0 start_time \cb3\cf12 = (\cb3\cf8\b float\b0\cb3\cf12 )\cb1\cf0 rt_get_time_ns\cb3\cf12 ()/\cb3\cf7 1E9\cb3\cf12 ; \cb3\cf2 //in seconds
\par \cb1\cf0\ul0\i0\b0 146       \cb1\cf0 old_time \cb3\cf12 = \cb1\cf0 start_time\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 147       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "AnalogOutputChannel board_it is %p \n"\cb3\cf12 ,\cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 board_id\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 148       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "AnalogOutputChannel devicename is %p \n"\cb3\cf12 ,*(\cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 devicename\cb3\cf12 ));
\par \cb1\cf0\ul0\i0\b0 149       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "AnalogOutputChannel boardname is %p \n"\cb3\cf12 ,*(\cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 boardname\cb3\cf12 ));
\par \cb1\cf0\ul0\i0\b0 150       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "AnalogOutputChannel subdevice is %d \n"\cb3\cf12 ,\cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 151       \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "AnalogOutputChannel channel is %d \n"\cb3\cf12 ,\cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 channel\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 152       \cb1\cf0 OutputValue \cb3\cf12 = \cb3\cf7 1\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 153       \cb3\cf2 //sine_loop_running = 0;  //set this to 0 for testing
\par \cb1\cf0\ul0\i0\b0 154       \cb3\cf8\b while\b0\cb3\cf12 (\cb1\cf0 sine_loop_running\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0 155       \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 156          \cb1\cf0 i\cb3\cf12 ++; \cb3\cf2 // Count Loops.
\par \cb1\cf0\ul0\i0\b0 157          \cb1\cf0 current_time \cb3\cf12 = (\cb3\cf8\b float\b0\cb3\cf12 )\cb1\cf0 rt_get_time_ns\cb3\cf12 ()/\cb3\cf7 1E9\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 158          \cb3\cf2 //rt_printk("LOOP %d,-- Period time: %f12 %f12\n",i, current_time - old_time,count2nano((float)sampling_interval)/1E9);
\par \cb1\cf0\ul0\i0\b0 159          \cb1\cf0 OutputValue \cb3\cf12 = \cb1\cf0 SineWaveAmplitude\cb3\cf12 *\cb1\cf0 sin\cb3\cf12 (\cb3\cf7 2\cb3\cf12 *\cb1\cf0 PI\cb3\cf12 *\cb1\cf0 SineWaveFrequency\cb3\cf12 *(\cb1\cf0 current_time\cb3\cf12 -\cb1\cf0 start_time\cb3\cf12 ));
\par \cb1\cf0\ul0\i0\b0 160          \cb3\cf2 //OutputValue = -1*OutputValue;
\par \cb1\cf0\ul0\i0\b0 161          \cb3\cf2 //rt_printk("OutputValue is %f12 \n",OutputValue);
\par \cb1\cf0\ul0\i0\b0 162          \cb1\cf0 data_to_card \cb3\cf12 = (\cb1\cf0 lsampl_t\cb3\cf12 ) \cb1\cf0 nearbyint\cb3\cf12 (((\cb1\cf0 OutputValue \cb3\cf12 - \cb1\cf0 MinOutputVoltage\cb3\cf12 )/\cb1\cf0 OutputRange\cb3\cf12 )*\cb1\cf0 MaxOutputBits\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 163          \cb3\cf2 //m=rt_comedi_command_data_write(AnalogOutputChannel.board_id, AnalogOutputChannel.subdevice, NCHAN, data_to_card);
\par \cb1\cf0\ul0\i0\b0 164          \cb1\cf0 comedi_lock\cb3\cf12 (\cb1\cf0 dev\cb3\cf12 , \cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 165          \cb1\cf0 m\cb3\cf12 =\cb1\cf0 comedi_data_write\cb3\cf12 (\cb1\cf0 dev\cb3\cf12 , \cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 , \cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 channel\cb3\cf12 , \cb1\cf0 AO_RANGE\cb3\cf12 , \cb1\cf0 AREF_DIFF\cb3\cf12 , \cb1\cf0 data_to_card\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 166          \cb1\cf0 comedi_unlock\cb3\cf12 (\cb1\cf0 dev\cb3\cf12 , \cb1\cf0 AnalogOutputChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 167  \cb3\cf2 //        m=comedi_data_write(AnalogOutputChannel.board_id, AnalogOutputChannel.subdevice,
\par \cb1\cf0\ul0\i0\b0 168  \cb3\cf2 //               AnalogOutputChannel.channel, AO_RANGE, AREF_GROUND, data_to_card);
\par \cb1\cf0\ul0\i0\b0 169          \cb3\cf2 //rt_printk("Data_to_card is %d; result from rt_comedi_command_data_write is %d \n",data_to_card, m);
\par \cb1\cf0\ul0\i0\b0 170          \cb3\cf2 //rt_printk("LOOP %d,-- AO Out time: %f12 \n",i, (float)rt_get_time_ns()/1E9 - current_time);
\par \cb1\cf0\ul0\i0\b0 171          \cb3\cf2 //rt_printk("Data_to_card is %d \n",data_to_card);
\par \cb1\cf0\ul0\i0\b0 172          \cb3\cf2 //old_time = current_time;
\par \cb1\cf0\ul0\i0\b0 173  \cb3\cf2 /*        if (i== 100000)
\par \cb1\cf0\ul0\i0\b0 174          \cb3\cf2 \{
\par \cb1\cf0\ul0\i0\b0 175              \cb3\cf2 sine_loop_running = 0;
\par \cb1\cf0\ul0\i0\b0 176              \cb3\cf2 //printf("LOOP -- run: %d %d\n ",keep_on_running,&keep_on_running);
\par \cb1\cf0\ul0\i0\b0 177              \cb3\cf2 //printf("RTAI LOOP -- run: %d \n ",i);
\par \cb1\cf0\ul0\i0\b0 178              \cb3\cf2 break;
\par \cb1\cf0\ul0\i0\b0 179          \cb3\cf2 \}
\par \cb1\cf0\ul0\i0\b0 180  \cb3\cf2 */
\par \cb1\cf0\ul0\i0\b0 181          \cb1\cf0 rt_task_wait_period\cb3\cf12 (); \cb3\cf2 // And waits until the end of the period.
\par \cb1\cf0\ul0\i0\b0 182  
\par \cb1\cf0\ul0\i0\b0 183      \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 184      \cb1\cf0 rt_make_soft_real_time\cb3\cf12 ();
\par \cb1\cf0\ul0\i0\b0 185      \cb1\cf0 comedi_close\cb3\cf12 (\cb1\cf0 dev\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 186      \cb1\cf0 rt_task_delete\cb3\cf12 (\cb1\cf0 Sinewaveloop_Task\cb3\cf12 ); \cb3\cf2 //Self termination at end.
\par \cb1\cf0\ul0\i0\b0 187  
\par \cb1\cf0\ul0\i0\b0 188      \cb1\cf0 pthread_exit\cb3\cf12 (\cb1\cf0 NULL\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 189      \cb3\cf8\b return \b0\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 190   \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 191  
\par \cb1\cf0\ul0\i0\b0 192  
\par \cb1\cf0\ul0\i0\b0 193  \cb3\cf2 //*******************************************************************************
\par \cb1\cf0\ul0\i0\b0 194  \cb3\cf8\b int \b0\cb1\cf0 pid_loop\cb3\cf12 ()
\par \cb1\cf0\ul0\i0\b0 195  
\par \cb1\cf0\ul0\i0\b0 196  \cb3\cf2 //Modified on May 8 to take into account a moving average, and a moving variance
\par \cb1\cf0\ul0\i0\b0 197  \cb3\cf2 //and also to remove the retraction of the piezo except on the first pass.
\par \cb1\cf0\ul0\i0\b0 198  
\par \cb1\cf0\ul0\i0\b0 199  \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 200  \cb3\cf2 //This is the function to output a PID loop
\par \cb1\cf0\ul0\i0\b0 201  \cb3\cf2 //PID algorithm taken from Control System Desgin, by Karl Johan Astrom
\par \cb1\cf0\ul0\i0\b0 202  \cb3\cf2 //Chapter 6
\par \cb1\cf0\ul0\i0\b0 203  \cb3\cf2 //This algorithm is supposed to include integral wind-up and bumpless transition
\par \cb1\cf0\ul0\i0\b0 204  
\par \cb1\cf0\ul0\i0\b0 205      \cb3\cf8\b int \b0\cb1\cf0 m\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 206      \cb1\cf0 lsampl_t data_to_card\cb3\cf12 , \cb1\cf0 data_from_card\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 207      \cb3\cf8\b static \b0\cb1\cf0 comedi_t \cb3\cf12 * \cb1\cf0 dev_output\cb3\cf12 , * \cb1\cf0 dev_input\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 208      \cb3\cf8\b static double \b0\cb1\cf0 bi\cb3\cf12 , \cb1\cf0 ad\cb3\cf12 , \cb1\cf0 bd\cb3\cf12 ; \cb3\cf2 //PID coefficients
\par \cb1\cf0\ul0\i0\b0 209      \cb3\cf8\b static double \b0\cb1\cf0 Pcontrib\cb3\cf12 , \cb1\cf0 Icontrib\cb3\cf12 , \cb1\cf0 Dcontrib\cb3\cf12 ; \cb3\cf2 //individual PID contributions
\par \cb1\cf0\ul0\i0\b0 210      \cb3\cf8\b static double \b0\cb1\cf0 FeedbackReading\cb3\cf12 ; \cb3\cf2 //Readings of the error chann
\par \cb1\cf0\ul0\i0\b0 211      \cb3\cf8\b static double \b0\cb1\cf0 v\cb3\cf12 ; \cb3\cf2 //u is the actuator output, and v is the calculated output
\par \cb1\cf0\ul0\i0\b0 212      \cb3\cf8\b static int \b0\cb1\cf0 j \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 213      \cb3\cf8\b static double \b0\cb1\cf0 LastDiffContrib\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 214      \cb3\cf8\b static double \b0\cb1\cf0 Error\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 215      \cb3\cf8\b static double \b0\cb1\cf0 LastError \cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 216      \cb3\cf8\b static double \b0\cb1\cf0 SecondLastError \cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 217      \cb3\cf8\b static double \b0\cb1\cf0 LastOutput \cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 218      \cb3\cf2 //static double SummedPIDOutput; //Summed PID Output
\par \cb1\cf0\ul0\i0\b0 219      \cb3\cf8\b static double \b0\cb1\cf0 SummedFeedbackReading\cb3\cf12 ; \cb3\cf2 //Summed FeedbackReading
\par \cb1\cf0\ul0\i0\b0 220      \cb3\cf2 //static double SummedVariance;
\par \cb1\cf0\ul0\i0\b0 221      \cb3\cf8\b static double \b0\cb1\cf0 M2_n\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 222      \cb3\cf8\b static double \b0\cb1\cf0 delta\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 223      \cb3\cf8\b static double \b0\cb1\cf0 alpha\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 224      \cb3\cf8\b static struct \b0\cb1\cf0 queue PIDOutput_queue\cb3\cf12 ;\cb3\cf2 //these are two queues to calculate the moving mean and variance
\par \cb1\cf0\ul0\i0\b0 225      \cb3\cf8\b static struct \b0\cb1\cf0 queue FeedbackReadingVar_queue\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 226      \cb3\cf8\b static struct \b0\cb1\cf0 queue FeedbackReading_queue\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 227      \cb3\cf8\b static int \b0\cb1\cf0 NumbFirstSteps\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 228      \cb3\cf8\b static double \b0\cb1\cf0 InitialStepSizeVoltage \cb3\cf12 = \cb3\cf7 0.1\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 229      \cb3\cf8\b static double \b0\cb1\cf0 InitialVoltageStep\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 230      \cb3\cf8\b double \b0\cb1\cf0 last_mean\cb3\cf12 , \cb1\cf0 last_var\cb3\cf12 , \cb1\cf0 new_var\cb3\cf12 ; \cb3\cf2 //popped values of mean and variance
\par \cb1\cf0\ul0\i0\b0 231  
\par \cb1\cf0\ul0\i0\b0 232  
\par \cb1\cf0\ul0\i0\b0 233  
\par \cb1\cf0\ul0\i0\b0 234      \cb3\cf2 //Initialize the queues
\par \cb1\cf0\ul0\i0\b0 235      \cb1\cf0 init_queue\cb3\cf12 (&\cb1\cf0 PIDOutput_queue\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 236      \cb1\cf0 init_queue\cb3\cf12 (&\cb1\cf0 FeedbackReadingVar_queue\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 237      \cb1\cf0 init_queue\cb3\cf12 (&\cb1\cf0 FeedbackReading_queue\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 238  
\par \cb1\cf0\ul0\i0\b0 239      \cb3\cf2 //rt_printk("Control channel device name is %s \n",device_names[ControlChannel.board_number]);
\par \cb1\cf0\ul0\i0\b0 240      \cb3\cf2 //rt_printk("Control channel subdevice %d and channel %d \n", ControlChannel.subdevice, ControlChannel.channel);
\par \cb1\cf0\ul0\i0\b0 241  
\par \cb1\cf0\ul0\i0\b0 242      \cb3\cf2 //rt_printk("Feedback channel device name is %s \n",device_names[FeedbackChannel.board_number]);
\par \cb1\cf0\ul0\i0\b0 243      \cb3\cf2 //rt_printk("Feedback channel subdevice %d and channel %d \n", FeedbackChannel.subdevice, FeedbackChannel.channel);
\par \cb1\cf0\ul0\i0\b0 244  
\par \cb1\cf0\ul0\i0\b0 245      \cb3\cf2 //dev_output is the channel that is to be controlled
\par \cb1\cf0\ul0\i0\b0 246      \cb1\cf0 dev_output \cb3\cf12 = \cb1\cf0 comedi_open\cb3\cf12 (\cb1\cf0 device_names\cb3\cf12 [\cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 board_number\cb3\cf12 ]);
\par \cb1\cf0\ul0\i0\b0 247      \cb3\cf2 //dev_input is the channel from which the error signal is read
\par \cb1\cf0\ul0\i0\b0 248      \cb1\cf0 dev_input \cb3\cf12 = \cb1\cf0 comedi_open\cb3\cf12 (\cb1\cf0 device_names\cb3\cf12 [\cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 board_number\cb3\cf12 ]);
\par \cb1\cf0\ul0\i0\b0 249  
\par \cb1\cf0\ul0\i0\b0 250      \cb3\cf2 //initialize the task
\par \cb1\cf0\ul0\i0\b0 251      \cb3\cf8\b if\b0\cb3\cf12 (!(\cb1\cf0 PIDloop_Task \cb3\cf12 = \cb1\cf0 rt_task_init_schmod\cb3\cf12 (\cb1\cf0 nam2num\cb3\cf12 ( \cb3\cf10 "PIDLoop" \cb3\cf12 ), \cb3\cf2 // Name
\par \cb1\cf0\ul0\i0\b0 252                                          \cb3\cf7 2\cb3\cf12 , \cb3\cf2 // Priority
\par \cb1\cf0\ul0\i0\b0 253                                          \cb3\cf7 0\cb3\cf12 , \cb3\cf2 // Stack Size
\par \cb1\cf0\ul0\i0\b0 254                                          \cb3\cf7 0\cb3\cf12 , \cb3\cf2 //, // max_msg_size
\par \cb1\cf0\ul0\i0\b0 255                                          \cb1\cf0 SCHED_FIFO\cb3\cf12 , \cb3\cf2 // Policy
\par \cb1\cf0\ul0\i0\b0 256                                          \cb1\cf0 CPUMAP \cb3\cf12 ))) \cb3\cf2 // cpus_allowed
\par \cb1\cf0\ul0\i0\b0 257          \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 258              \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "ERROR: Cannot initialize PIDLoop task\n"\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 259              \cb1\cf0 exit\cb3\cf12 (\cb3\cf7 1\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 260          \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 261  
\par \cb1\cf0\ul0\i0\b0 262      \cb3\cf2 //specify that this is to run on one CPU
\par \cb1\cf0\ul0\i0\b0 263      \cb1\cf0 rt_set_runnable_on_cpuid\cb3\cf12 (\cb1\cf0 PIDloop_Task\cb3\cf12 , \cb3\cf7 0\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 264  
\par \cb1\cf0\ul0\i0\b0 265  
\par \cb1\cf0\ul0\i0\b0 266      \cb3\cf2 //lock memory and make hard real time
\par \cb1\cf0\ul0\i0\b0 267      \cb1\cf0 mlockall\cb3\cf12 (\cb1\cf0 MCL_CURRENT\cb3\cf12 |\cb1\cf0 MCL_FUTURE\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 268      \cb1\cf0 rt_make_hard_real_time\cb3\cf12 ();
\par \cb1\cf0\ul0\i0\b0 269  
\par \cb1\cf0\ul0\i0\b0 270      \cb3\cf2 //Convert PIDLoop_time, which is in nanoseconds, to tick time (sampling_interval, in counts)
\par \cb1\cf0\ul0\i0\b0 271      \cb1\cf0 sampling_interval \cb3\cf12 =\cb1\cf0 nano2count\cb3\cf12 (\cb1\cf0 PIDLoop_Time\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 272  
\par \cb1\cf0\ul0\i0\b0 273      \cb3\cf2 // Let's make this task periodic..
\par \cb1\cf0\ul0\i0\b0 274      \cb1\cf0 expected \cb3\cf12 = \cb1\cf0 rt_get_time\cb3\cf12 () + \cb3\cf7 100\cb3\cf12 *\cb1\cf0 sampling_interval\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 275      \cb1\cf0 rt_task_make_periodic\cb3\cf12 (\cb1\cf0 PIDloop_Task\cb3\cf12 , \cb1\cf0 expected\cb3\cf12 , \cb1\cf0 sampling_interval\cb3\cf12 ); \cb3\cf2 //period in counts
\par \cb1\cf0\ul0\i0\b0 276  
\par \cb1\cf0\ul0\i0\b0 277  
\par \cb1\cf0\ul0\i0\b0 278      \cb1\cf0 pid_loop_running \cb3\cf12 = \cb3\cf7 1\cb3\cf12 ; \cb3\cf2 //set the pid loop running flag to FALSE
\par \cb1\cf0\ul0\i0\b0 279  
\par \cb1\cf0\ul0\i0\b0 280      \cb3\cf2 //retract the tip completely, if it is the first PID pass
\par \cb1\cf0\ul0\i0\b0 281      \cb3\cf8\b if\b0\cb3\cf12 (\cb1\cf0 FirstPIDPass\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0 282        \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 283          \cb3\cf2 //data_to_card = (lsampl_t) 0;
\par \cb1\cf0\ul0\i0\b0 284          \cb3\cf2 //MaxZVoltage corresponds to the fully retracted piezo
\par \cb1\cf0\ul0\i0\b0 285          \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "MaxZVoltage is %f \n"\cb3\cf12 , \cb1\cf0 MaxZVoltage\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 286          \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "MinZVoltage is %f \n"\cb3\cf12 , \cb1\cf0 MinZVoltage\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 287          \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "MinOutputVoltage is %f \n"\cb3\cf12 , \cb1\cf0 MinOutputVoltage\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 288          \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "PIDOutput is %f \n"\cb3\cf12 , \cb1\cf0 PIDOutput\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 289          \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "AmplifierGainSign is %i \n"\cb3\cf12 , \cb1\cf0 AmplifierGainSign\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 290          \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "OutputPhase is %i \n"\cb3\cf12 , \cb1\cf0 OutputPhase\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 291          \cb1\cf0 NumbFirstSteps \cb3\cf12 = (\cb1\cf0 nearbyint\cb3\cf12 ((\cb1\cf0 MaxZVoltage\cb3\cf12 -\cb1\cf0 PIDOutput\cb3\cf12 )/\cb1\cf0 InitialStepSizeVoltage\cb3\cf12 ))-\cb3\cf7 1\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 292         \cb3\cf2 //NumbFirstSteps = ((MaxZVoltage - PIDOutput)/InitialStepSizeVoltage)); //-1 to  be safe
\par \cb1\cf0\ul0\i0\b0 293          \cb3\cf2 //Set the direction of the voltage step
\par \cb1\cf0\ul0\i0\b0 294          \cb3\cf2 //PIDOutput = CurrentZVoltage;
\par \cb1\cf0\ul0\i0\b0 295          \cb3\cf8\b if \b0\cb3\cf12 (\cb1\cf0 MaxZVoltage\cb3\cf12 >=\cb1\cf0 PIDOutput\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0 296            \cb3\cf12 \{\cb1\cf0 InitialVoltageStep\cb3\cf12 =\cb1\cf0 InitialStepSizeVoltage\cb3\cf12 ;\}
\par \cb1\cf0\ul0\i0\b0 297           \cb3\cf8\b else \b0\cb3\cf12 \{\cb1\cf0 InitialVoltageStep\cb3\cf12 =-\cb1\cf0 InitialStepSizeVoltage\cb3\cf12 ;\};
\par \cb1\cf0\ul0\i0\b0 298  
\par \cb1\cf0\ul0\i0\b0 299          \cb3\cf8\b if \b0\cb3\cf12 (\cb1\cf0 NumbFirstSteps\cb3\cf12 >\cb3\cf7 1\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0 300            \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 301              \cb3\cf8\b for\b0\cb3\cf12 (\cb1\cf0 j\cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;\cb1\cf0 j\cb3\cf12 <\cb1\cf0 NumbFirstSteps\cb3\cf12 ;\cb1\cf0 j\cb3\cf12 ++)
\par \cb1\cf0\ul0\i0\b0 302                \cb3\cf12 \{  \cb1\cf0 PIDOutput\cb3\cf12 +=\cb1\cf0 InitialVoltageStep\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 303                   \cb1\cf0 data_to_card \cb3\cf12 = (\cb1\cf0 lsampl_t\cb3\cf12 ) \cb1\cf0 nearbyint\cb3\cf12 (((\cb1\cf0 PIDOutput \cb3\cf12 - \cb1\cf0 MinOutputVoltage\cb3\cf12 )/\cb1\cf0 OutputRange\cb3\cf12 )*\cb1\cf0 MaxOutputBits\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 304                   \cb3\cf2 //rt_printk("Data_to_card is %i \n", data_to_card);
\par \cb1\cf0\ul0\i0\b0 305                   \cb1\cf0 comedi_lock\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 306                   \cb1\cf0 m\cb3\cf12 =\cb1\cf0 comedi_data_write\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 channel\cb3\cf12 , \cb1\cf0 AO_RANGE\cb3\cf12 , \cb1\cf0 AREF_DIFF\cb3\cf12 , \cb1\cf0 data_to_card\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 307                   \cb1\cf0 comedi_unlock\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 308                  \cb3\cf2 // And wait until the end of the period.
\par \cb1\cf0\ul0\i0\b0 309                  \cb1\cf0 rt_task_wait_period\cb3\cf12 ();
\par \cb1\cf0\ul0\i0\b0 310                \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 311            \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 312          \cb3\cf2 //Initialize the errors
\par \cb1\cf0\ul0\i0\b0 313          \cb1\cf0 LastError \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 314          \cb1\cf0 SecondLastError \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 315          \cb1\cf0 LastOutput \cb3\cf12 = \cb1\cf0 PIDOutput\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 316          \cb1\cf0 LastDiffContrib \cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 317          \cb1\cf0 Dcontrib \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 318          \cb1\cf0 Icontrib \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 319          \cb1\cf0 AveragedPIDOutput\cb3\cf12 =\cb1\cf0 LastOutput\cb3\cf12 ;  \cb3\cf2 //This is what the main program will actually read
\par \cb1\cf0\ul0\i0\b0 320          \cb1\cf0 FirstPIDPass \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 321        \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 322  
\par \cb1\cf0\ul0\i0\b0 323  
\par \cb1\cf0\ul0\i0\b0 324  
\par \cb1\cf0\ul0\i0\b0 325  
\par \cb1\cf0\ul0\i0\b0 326      \cb3\cf2 //rt_printk("AntiWindup time is %f \n", AntiWindup_Time);
\par \cb1\cf0\ul0\i0\b0 327      \cb1\cf0 bi \cb3\cf12 = \cb1\cf0 PropCoff\cb3\cf12 *\cb1\cf0 PIDLoop_Time\cb3\cf12 /\cb1\cf0 IntTime\cb3\cf12 ;  \cb3\cf2 //integral gain
\par \cb1\cf0\ul0\i0\b0 328      \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "PropCoff is %f \n"\cb3\cf12 , \cb1\cf0 PropCoff\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 329      \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "IntTime is %f \n"\cb3\cf12 , \cb1\cf0 IntTime\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 330      \cb3\cf2 //in Astrom's article, ad is defined as below in the code, but the actual
\par \cb1\cf0\ul0\i0\b0 331      \cb3\cf2 //derivation gives the coefficient we actually use
\par \cb1\cf0\ul0\i0\b0 332      \cb3\cf2 //ad = (2*DiffTime- PID_cutoff_N*PIDLoop_Time)/(2*DiffTime+PID_cutoff_N*PIDLoop_Time);
\par \cb1\cf0\ul0\i0\b0 333      \cb1\cf0 ad \cb3\cf12 = (\cb1\cf0 DiffTime\cb3\cf12 )/(\cb1\cf0 DiffTime\cb3\cf12 +\cb1\cf0 PID_cutoff_N\cb3\cf12 *\cb1\cf0 PIDLoop_Time\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 334      \cb1\cf0 rt_printk\cb3\cf12 (\cb3\cf10 "DiffTime is %f \n"\cb3\cf12 , \cb1\cf0 DiffTime\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 335      \cb3\cf2 //same comment about bd
\par \cb1\cf0\ul0\i0\b0 336      \cb3\cf2 //bd = 2*PropCoff*PID_cutoff_N*DiffTime/(2*DiffTime + PID_cutoff_N*PIDLoop_Time);    //derivative gain
\par \cb1\cf0\ul0\i0\b0 337      \cb1\cf0 bd \cb3\cf12 = \cb1\cf0 PropCoff\cb3\cf12 *\cb1\cf0 PID_cutoff_N\cb3\cf12 *\cb1\cf0 DiffTime\cb3\cf12 /(\cb1\cf0 DiffTime \cb3\cf12 + \cb1\cf0 PID_cutoff_N\cb3\cf12 *\cb1\cf0 PIDLoop_Time\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 338      \cb3\cf2 //rt_printk("MaxZVoltage is %f \n", MaxZVoltage);
\par \cb1\cf0\ul0\i0\b0 339  
\par \cb1\cf0\ul0\i0\b0 340  
\par \cb1\cf0\ul0\i0\b0 341      \cb3\cf2 //Now calculate the initial means and variances
\par \cb1\cf0\ul0\i0\b0 342      \cb3\cf2 //SummedPIDOutput = 0; //initialize parameters if we take averages
\par \cb1\cf0\ul0\i0\b0 343      \cb3\cf2 //First means
\par \cb1\cf0\ul0\i0\b0 344      \cb1\cf0 SummedFeedbackReading \cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 345      \cb3\cf2 //j=1;
\par \cb1\cf0\ul0\i0\b0 346      \cb1\cf0 alpha \cb3\cf12 =  ((\cb3\cf8\b float\b0\cb3\cf12 ) \cb3\cf7 1\cb3\cf12 )/(\cb1\cf0 PID_averages\cb3\cf12 +\cb3\cf7 1\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 347      \cb3\cf8\b for \b0\cb3\cf12 (\cb1\cf0 j\cb3\cf12 =\cb3\cf7 0\cb3\cf12 ;\cb1\cf0 j\cb3\cf12 <\cb1\cf0 PID_averages\cb3\cf12 ;\cb1\cf0 j\cb3\cf12 ++)
\par \cb1\cf0\ul0\i0\b0 348        \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 349  
\par \cb1\cf0\ul0\i0\b0 350          \cb3\cf2 //make a first reading
\par \cb1\cf0\ul0\i0\b0 351          \cb1\cf0 comedi_lock\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 352          \cb1\cf0 m \cb3\cf12 = \cb1\cf0 comedi_data_read\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 channel\cb3\cf12 , \cb1\cf0 AI_RANGE\cb3\cf12 , \cb1\cf0 AREF_DIFF\cb3\cf12 , &\cb1\cf0 data_from_card\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 353          \cb1\cf0 comedi_unlock\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 354  
\par \cb1\cf0\ul0\i0\b0 355          \cb3\cf2 //Convert to a voltage reading
\par \cb1\cf0\ul0\i0\b0 356          \cb1\cf0 SummedFeedbackReading \cb3\cf12 += ((((\cb3\cf8\b float\b0\cb3\cf12 ) \cb1\cf0 data_from_card\cb3\cf12 )/\cb1\cf0 MaxInputBits\cb3\cf12 )*\cb1\cf0 InputRange \cb3\cf12 + \cb1\cf0 MinInputVoltage\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 357        \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 358      \cb1\cf0 AveragedFeedbackReading \cb3\cf12 =\cb1\cf0 SummedFeedbackReading\cb3\cf12 /\cb1\cf0 PID_averages\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 359  
\par \cb1\cf0\ul0\i0\b0 360  
\par \cb1\cf0\ul0\i0\b0 361      \cb3\cf2 //Since we are not changing the output, the mean has not changed, and the variance is 0
\par \cb1\cf0\ul0\i0\b0 362      \cb1\cf0 M2_n \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 363      \cb1\cf0 PIDOutputVariance \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 364  
\par \cb1\cf0\ul0\i0\b0 365      \cb3\cf2 //Initialize the circular buffers
\par \cb1\cf0\ul0\i0\b0 366      \cb3\cf8\b for \b0\cb3\cf12 (\cb1\cf0 j\cb3\cf12 =\cb3\cf7 0\cb3\cf12 ; \cb1\cf0 j\cb3\cf12 <\cb1\cf0 PID_averages\cb3\cf12 ; \cb1\cf0 j\cb3\cf12 ++)
\par \cb1\cf0\ul0\i0\b0 367        \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 368          \cb1\cf0 push_queue\cb3\cf12 (&\cb1\cf0 FeedbackReading_queue\cb3\cf12 , \cb1\cf0 AveragedFeedbackReading\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 369          \cb1\cf0 push_queue\cb3\cf12 (&\cb1\cf0 FeedbackReadingVar_queue\cb3\cf12 , \cb1\cf0 PIDOutputVariance\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 370          \cb1\cf0 push_queue\cb3\cf12 (&\cb1\cf0 PIDOutput_queue\cb3\cf12 , \cb1\cf0 LastOutput\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 371        \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 372  
\par \cb1\cf0\ul0\i0\b0 373      \cb3\cf2 //Now do the regular loop
\par \cb1\cf0\ul0\i0\b0 374      \cb3\cf8\b while\b0\cb3\cf12 (\cb1\cf0 pid_loop_running\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0 375        \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 376        \cb3\cf2 //rt_printk("Got here 1 \n");
\par \cb1\cf0\ul0\i0\b0 377        \cb3\cf2 //check to see if the PID parameters have changed
\par \cb1\cf0\ul0\i0\b0 378        \cb3\cf8\b if\b0\cb3\cf12 (\cb1\cf0 PIDParametersChanged\cb3\cf12 )
\par \cb1\cf0\ul0\i0\b0 379          \cb3\cf12 \{
\par \cb1\cf0\ul0\i0\b0 380            \cb3\cf2 //update the PID coefficients
\par \cb1\cf0\ul0\i0\b0 381            \cb1\cf0 bi \cb3\cf12 = \cb1\cf0 PropCoff\cb3\cf12 *\cb1\cf0 PIDLoop_Time\cb3\cf12 /\cb1\cf0 IntTime\cb3\cf12 ;  \cb3\cf2 //integral gain
\par \cb1\cf0\ul0\i0\b0 382            \cb1\cf0 ad \cb3\cf12 = (\cb1\cf0 DiffTime\cb3\cf12 )/(\cb1\cf0 DiffTime\cb3\cf12 +\cb1\cf0 PID_cutoff_N\cb3\cf12 *\cb1\cf0 PIDLoop_Time\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 383            \cb1\cf0 bd \cb3\cf12 = \cb1\cf0 PropCoff\cb3\cf12 *\cb1\cf0 PID_cutoff_N\cb3\cf12 *\cb1\cf0 DiffTime\cb3\cf12 /(\cb1\cf0 DiffTime \cb3\cf12 + \cb1\cf0 PID_cutoff_N\cb3\cf12 *\cb1\cf0 PIDLoop_Time\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 384            \cb1\cf0 PIDParametersChanged \cb3\cf12 = \cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 385          \cb3\cf12 \} \cb3\cf2 //end of if(PIDParametersChanged)
\par \cb1\cf0\ul0\i0\b0 386  
\par \cb1\cf0\ul0\i0\b0 387        \cb3\cf2 //continue with the rest of the loop
\par \cb1\cf0\ul0\i0\b0 388  
\par \cb1\cf0\ul0\i0\b0 389        \cb3\cf2 //Read the input reading
\par \cb1\cf0\ul0\i0\b0 390        \cb1\cf0 comedi_lock\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 391        \cb1\cf0 m \cb3\cf12 = \cb1\cf0 comedi_data_read\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 channel\cb3\cf12 , \cb1\cf0 AI_RANGE\cb3\cf12 , \cb1\cf0 AREF_DIFF\cb3\cf12 , &\cb1\cf0 data_from_card\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 392        \cb1\cf0 comedi_unlock\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 , \cb1\cf0 FeedbackChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 393  
\par \cb1\cf0\ul0\i0\b0 394        \cb3\cf2 //Convert to a voltage reading
\par \cb1\cf0\ul0\i0\b0 395        \cb1\cf0 FeedbackReading \cb3\cf12 = ((((\cb3\cf8\b float\b0\cb3\cf12 ) \cb1\cf0 data_from_card\cb3\cf12 )/\cb1\cf0 MaxInputBits\cb3\cf12 )*\cb1\cf0 InputRange \cb3\cf12 + \cb1\cf0 MinInputVoltage\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 396        \cb3\cf2 //rt_printk("Data from card is %d \n", data_from_card);
\par \cb1\cf0\ul0\i0\b0 397        \cb3\cf2 //rt_printk("Feedback reading is %f \n", FeedbackReading);
\par \cb1\cf0\ul0\i0\b0 398        \cb3\cf2 //rt_printk("Input m is %d \n", m);
\par \cb1\cf0\ul0\i0\b0 399        \cb1\cf0 delta \cb3\cf12 = (\cb1\cf0 FeedbackReading \cb3\cf12 - \cb1\cf0 AveragedFeedbackReading\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 400        \cb3\cf2 //AveragedFeedbackReading = alpha*FeedbackReading+(1-alpha)*AveragedFeedbackReading;  //running averange
\par \cb1\cf0\ul0\i0\b0 401        \cb3\cf2 //PIDOutputVariance = alpha*(delta*delta) + (1-alpha)*PIDOutputVariance;
\par \cb1\cf0\ul0\i0\b0 402        \cb1\cf0 Error \cb3\cf12 = \cb1\cf0 AmplifierGainSign\cb3\cf12 *\cb1\cf0 OutputPhase\cb3\cf12 *(\cb1\cf0 SetPoint \cb3\cf12 - \cb1\cf0 FeedbackReading\cb3\cf12 );\cb3\cf2 //multiply by OutputPhase+AmplifierGainSign
\par \cb1\cf0\ul0\i0\b0 403        \cb1\cf0 Pcontrib \cb3\cf12 = \cb1\cf0 PropCoff\cb3\cf12 *(\cb1\cf0 Error \cb3\cf12 - \cb1\cf0 LastError\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 404        \cb3\cf2 //Not sure of sign of second contribution in line below...should it be - ?
\par \cb1\cf0\ul0\i0\b0 405        \cb1\cf0 Dcontrib \cb3\cf12 = \cb1\cf0 ad\cb3\cf12 *\cb1\cf0 LastDiffContrib \cb3\cf12 - \cb1\cf0 bd\cb3\cf12 *(\cb1\cf0 Error \cb3\cf12 - \cb3\cf7 2\cb3\cf12 *\cb1\cf0 LastError \cb3\cf12 + \cb1\cf0 SecondLastError\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 406        \cb1\cf0 v \cb3\cf12 = \cb1\cf0 LastOutput \cb3\cf12 + \cb1\cf0 Pcontrib \cb3\cf12 + \cb1\cf0 Icontrib \cb3\cf12 + \cb1\cf0 Dcontrib\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 407  
\par \cb1\cf0\ul0\i0\b0 408        \cb3\cf2 //next, take care of saturation of the output....anti-windup
\par \cb1\cf0\ul0\i0\b0 409        \cb1\cf0 PIDOutput \cb3\cf12 = \cb1\cf0 v\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 410        \cb1\cf0 PIDOutput \cb3\cf12 =(\cb1\cf0 PIDOutput\cb3\cf12 >\cb1\cf0 MaxOutputVoltage\cb3\cf12 )? \cb1\cf0 MaxOutputVoltage\cb3\cf12 :\cb1\cf0 PIDOutput\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 411        \cb1\cf0 PIDOutput \cb3\cf12 =(\cb1\cf0 PIDOutput\cb3\cf12 <\cb1\cf0 MinOutputVoltage\cb3\cf12 )? \cb1\cf0 MinOutputVoltage\cb3\cf12 :\cb1\cf0 PIDOutput\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 412  
\par \cb1\cf0\ul0\i0\b0 413        \cb3\cf2 //Calculate the averaged quantities
\par \cb1\cf0\ul0\i0\b0 414        \cb1\cf0 pop_queue\cb3\cf12 (&\cb1\cf0 FeedbackReading_queue\cb3\cf12 , &\cb1\cf0 last_mean\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 415        \cb1\cf0 AveragedFeedbackReading \cb3\cf12 += (\cb1\cf0 FeedbackReading \cb3\cf12 - \cb1\cf0 last_mean\cb3\cf12 )/\cb1\cf0 PID_averages\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 416        \cb1\cf0 push_queue\cb3\cf12 (&\cb1\cf0 FeedbackReading_queue\cb3\cf12 , \cb1\cf0 FeedbackReading\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 417  
\par \cb1\cf0\ul0\i0\b0 418        \cb1\cf0 pop_queue\cb3\cf12 (&\cb1\cf0 FeedbackReadingVar_queue\cb3\cf12 , &\cb1\cf0 last_var\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 419        \cb1\cf0 new_var \cb3\cf12 = \cb1\cf0 delta\cb3\cf12 *\cb1\cf0 delta\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 420        \cb1\cf0 PIDOutputVariance \cb3\cf12 += (\cb1\cf0 new_var \cb3\cf12 - \cb1\cf0 last_var\cb3\cf12 )/\cb1\cf0 PID_averages\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 421        \cb1\cf0 push_queue\cb3\cf12 (&\cb1\cf0 FeedbackReadingVar_queue\cb3\cf12 , \cb1\cf0 new_var\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 422  
\par \cb1\cf0\ul0\i0\b0 423        \cb3\cf2 //send the control signal
\par \cb1\cf0\ul0\i0\b0 424        \cb3\cf2 //rt_printk("FeedbackReading is %f \n", FeedbackReading);
\par \cb1\cf0\ul0\i0\b0 425        \cb3\cf2 //rt_printk("v is %f \n", v);
\par \cb1\cf0\ul0\i0\b0 426        \cb3\cf2 //rt_printk("PID output should be %f \n", PIDOutput);
\par \cb1\cf0\ul0\i0\b0 427        \cb1\cf0 data_to_card \cb3\cf12 = (\cb1\cf0 lsampl_t\cb3\cf12 ) \cb1\cf0 nearbyint\cb3\cf12 (((\cb1\cf0 PIDOutput \cb3\cf12 - \cb1\cf0 MinOutputVoltage\cb3\cf12 )/\cb1\cf0 OutputRange\cb3\cf12 )*\cb1\cf0 MaxOutputBits\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 428        \cb3\cf2 //data_to_card = (lsampl_t) 0;
\par \cb1\cf0\ul0\i0\b0 429        \cb1\cf0 comedi_lock\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 430        \cb1\cf0 m\cb3\cf12 =\cb1\cf0 comedi_data_write\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 channel\cb3\cf12 , \cb1\cf0 AO_RANGE\cb3\cf12 , \cb1\cf0 AREF_DIFF\cb3\cf12 , \cb1\cf0 data_to_card\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 431        \cb1\cf0 comedi_unlock\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 , \cb1\cf0 ControlChannel\cb3\cf12 .\cb1\cf0 subdevice\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 432        \cb3\cf2 //rt_printk("Output m is %d \n", m);
\par \cb1\cf0\ul0\i0\b0 433  
\par \cb1\cf0\ul0\i0\b0 434        \cb3\cf2 //Update the integral contribution after the loop
\par \cb1\cf0\ul0\i0\b0 435        \cb1\cf0 Icontrib \cb3\cf12 = \cb1\cf0 bi\cb3\cf12 *\cb1\cf0 Error\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 436  
\par \cb1\cf0\ul0\i0\b0 437        \cb3\cf2 //Update parameters
\par \cb1\cf0\ul0\i0\b0 438        \cb1\cf0 LastError \cb3\cf12 = \cb1\cf0 Error\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 439        \cb1\cf0 SecondLastError \cb3\cf12 = \cb1\cf0 LastError\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 440        \cb1\cf0 LastDiffContrib \cb3\cf12 = \cb1\cf0 Dcontrib\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 441        \cb1\cf0 LastOutput \cb3\cf12 = \cb1\cf0 PIDOutput\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 442  
\par \cb1\cf0\ul0\i0\b0 443  
\par \cb1\cf0\ul0\i0\b0 444        \cb3\cf2 //rt_printk("PContrib is %f \n", Pcontrib);
\par \cb1\cf0\ul0\i0\b0 445        \cb3\cf2 //rt_printk("IContrib is %f \n", Icontrib);
\par \cb1\cf0\ul0\i0\b0 446        \cb3\cf2 //rt_printk("DContrib is %f \n", Dcontrib);
\par \cb1\cf0\ul0\i0\b0 447        \cb3\cf2 //rt_printk("PIDOutput is %f \n", PIDOutput);
\par \cb1\cf0\ul0\i0\b0 448  
\par \cb1\cf0\ul0\i0\b0 449        \cb3\cf2 //Next part is to take the averaged PID output for recording if j>PID_averages and PID_averages>1
\par \cb1\cf0\ul0\i0\b0 450        \cb3\cf2 //SummedPIDOutput+=PIDOutput;
\par \cb1\cf0\ul0\i0\b0 451        \cb3\cf2 //SummedFeedbackReading += FeedbackReading;
\par \cb1\cf0\ul0\i0\b0 452        \cb3\cf2 //j++;
\par \cb1\cf0\ul0\i0\b0 453        \cb3\cf2 //AveragedPIDOutput=((PID_averages>1)&&(j>PID_averages))?(SummedPIDOutput/PID_averages):AveragedPIDOutput;
\par \cb1\cf0\ul0\i0\b0 454        \cb3\cf2 //AveragedFeedbackReading=((PID_averages>1)&&(j>PID_averages))?(SummedFeedbackReading/PID_averages):AveragedFeedbackReading;
\par \cb1\cf0\ul0\i0\b0 455        \cb3\cf2 //SummedPIDOutput=(j>PID_averages)? 0:SummedPIDOutput;
\par \cb1\cf0\ul0\i0\b0 456        \cb3\cf2 //SummedFeedbackReading=(j>PID_averages)? 0:SummedFeedbackReading;
\par \cb1\cf0\ul0\i0\b0 457        \cb3\cf2 //j=(j>PID_averages)? 1:j;
\par \cb1\cf0\ul0\i0\b0 458  
\par \cb1\cf0\ul0\i0\b0 459        \cb3\cf2 //Calculate moving exponential averages and variance
\par \cb1\cf0\ul0\i0\b0 460        \cb3\cf2 //delta = PIDOutput - AveragedPIDOutput;
\par \cb1\cf0\ul0\i0\b0 461        \cb3\cf2 //AveragedPIDOutput = alpha*PIDOutput + (1-alpha)*AveragedPIDOutput;
\par \cb1\cf0\ul0\i0\b0 462        \cb3\cf2 //PIDOutputVariance = alpha*(delta*delta) + (1-alpha)*PIDOutputVariance;
\par \cb1\cf0\ul0\i0\b0 463        \cb3\cf2 //PIDOutputVariance = alpha*abs(delta) + (1-alpha)*PIDOutputVariance;
\par \cb1\cf0\ul0\i0\b0 464  
\par \cb1\cf0\ul0\i0\b0 465        \cb1\cf0 pop_queue\cb3\cf12 (&\cb1\cf0 PIDOutput_queue\cb3\cf12 , &\cb1\cf0 last_mean\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 466        \cb1\cf0 AveragedPIDOutput \cb3\cf12 += (\cb1\cf0 PIDOutput \cb3\cf12 - \cb1\cf0 last_mean\cb3\cf12 )/\cb1\cf0 PID_averages\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 467        \cb1\cf0 push_queue\cb3\cf12 (&\cb1\cf0 PIDOutput_queue\cb3\cf12 , \cb1\cf0 PIDOutput\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 468           \cb3\cf2 // And wait until the end of the period.
\par \cb1\cf0\ul0\i0\b0 469          \cb1\cf0 rt_task_wait_period\cb3\cf12 ();
\par \cb1\cf0\ul0\i0\b0 470  
\par \cb1\cf0\ul0\i0\b0 471         \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 472  
\par \cb1\cf0\ul0\i0\b0 473      \cb3\cf2 //rt_printk("Got here 3 \n");
\par \cb1\cf0\ul0\i0\b0 474      \cb3\cf2 //rt_printk("pid_loop_running is %d \n", pid_loop_running);
\par \cb1\cf0\ul0\i0\b0 475      \cb1\cf0 rt_make_soft_real_time\cb3\cf12 ();
\par \cb1\cf0\ul0\i0\b0 476      \cb1\cf0 comedi_close\cb3\cf12 (\cb1\cf0 dev_input\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 477      \cb1\cf0 comedi_close\cb3\cf12 (\cb1\cf0 dev_output\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 478      \cb1\cf0 rt_task_delete\cb3\cf12 (\cb1\cf0 PIDloop_Task\cb3\cf12 ); \cb3\cf2 //Self termination at end.
\par \cb1\cf0\ul0\i0\b0 479  
\par \cb1\cf0\ul0\i0\b0 480      \cb1\cf0 pthread_exit\cb3\cf12 (\cb1\cf0 NULL\cb3\cf12 );
\par \cb1\cf0\ul0\i0\b0 481      \cb3\cf8\b return \b0\cb3\cf7 0\cb3\cf12 ;
\par \cb1\cf0\ul0\i0\b0 482  
\par \cb1\cf0\ul0\i0\b0 483  
\par \cb1\cf0\ul0\i0\b0 484  \cb3\cf12 \}
\par \cb1\cf0\ul0\i0\b0 485  
\par }